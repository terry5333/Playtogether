const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const path = require('path');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*" } // 確保跨域連線穩定
});

app.use(express.static(path.join(__dirname, 'public')));

// 遊戲資料儲存
let rooms = {};
const ADMIN_KEY = "admin888"; // 管理員後台密鑰

io.on('connection', (socket) => {
    console.log('新玩家連線:', socket.id);

    // --- 房間邏輯 ---

    // 1. 創建房間
    socket.on('create_room', () => {
        const roomId = Math.floor(1000 + Math.random() * 9000).toString();
        rooms[roomId] = {
            host: socket.id, // 核心：創建者即為房主
            players: [],
            gameStarted: false,
            gameType: null,
            config: {},
            scores: {},
            currentTurnIdx: 0,
            currentWord: "",
            startTime: null
        };
        console.log(`房間已創建: ${roomId}, 房主: ${socket.id}`);
        socket.emit('room_created', { roomId });
    });

    // 2. 加入房間
    socket.on('join_room', (data) => {
        const { roomId, username } = data;
        
        if (!rooms[roomId]) {
            return socket.emit('error_msg', '房間不存在，請檢查房號');
        }

        socket.join(roomId);
        socket.roomId = roomId;
        socket.username = username;

        // 如果房間目前沒有房主（例如原房主斷線），則讓加入者補位
        if (!rooms[roomId].host) {
            rooms[roomId].host = socket.id;
        }

        // 防止玩家重複加入名單
        const exists = rooms[roomId].players.find(p => p.id === socket.id);
        if (!exists) {
            rooms[roomId].players.push({ id: socket.id, name: username });
            rooms[roomId].scores[username] = 0;
        }

        console.log(`玩家 ${username} 加入房間 ${roomId}`);

        // 廣播更新房間資訊給所有人 (包含 hostId 供前端判定星星與按鈕)
        io.to(roomId).emit('room_update', {
            roomId: roomId,
            players: rooms[roomId].players,
            hostId: rooms[roomId].host,
            gameStarted: rooms[roomId].gameStarted,
            scores: rooms[roomId].scores
        });
    });

    // --- 遊戲核心邏輯 ---

    // 3. 房主發起遊戲 (帶參數)
    socket.on('start_game_with_config', (data) => {
        const room = rooms[data.roomId];
        if (room && room.host === socket.id) {
            room.gameStarted = true;
            room.gameType = data.gameType;
            room.config = data.config;

            console.log(`房間 ${data.roomId} 開始遊戲: ${data.gameType}`);

            if (data.gameType === 'draw') {
                // 你畫我猜初始化：輪替玩家
                startNewDrawTurn(data.roomId);
            } else if (data.gameType === 'spy') {
                // 誰是臥底初始化：分配詞彙
                assignSpyWords(data.roomId);
            } else {
                // 賓果或其他
                io.to(data.roomId).emit('game_begin', { 
                    gameType: data.gameType, 
                    config: data.config 
                });
            }
        }
    });

    // 你畫我猜：處理輪替與計分
    function startNewDrawTurn(roomId) {
        const room = rooms[roomId];
        const drawer = room.players[room.currentTurnIdx];
        room.startTime = Date.now();
        room.currentWord = ""; // 重置題目

        io.to(roomId).emit('draw_turn_start', {
            drawerId: drawer.id,
            drawerName: drawer.name
        });
    }

    socket.on('set_draw_word', (data) => {
        const room = rooms[data.roomId];
        if (room) {
            room.currentWord = data.word;
            io.to(data.roomId).emit('draw_ready');
        }
    });

    // 誰是臥底：分配詞彙
    function assignSpyWords(roomId) {
        const room = rooms[roomId];
        const wordPairs = [["珍珠奶茶", "燕麥奶茶"], ["鋼琴", "風琴"], ["漢堡", "三明治"], ["蘋果", "水梨"]];
        const pair = wordPairs[Math.floor(Math.random() * wordPairs.length)];
        const spyIdx = Math.floor(Math.random() * room.players.length);

        room.players.forEach((p, i) => {
            const isSpy = (i === spyIdx);
            io.to(p.id).emit('game_begin', {
                gameType: 'spy',
                word: isSpy ? pair[1] : pair[0],
                isSpy: isSpy,
                config: room.config
            });
        });
    }

    // --- 互動與同步 ---

    // 聊天與猜題判定
    socket.on('send_chat', (data) => {
        const room = rooms[data.roomId];
        
        // 如果是你畫我猜模式且正在進行
        if (room && room.gameStarted && room.gameType === 'draw' && room.currentWord) {
            if (data.text.trim() === room.currentWord.trim()) {
                const elapsed = (Date.now() - room.startTime) / 1000;
                let pts = 1;
                if (elapsed <= 60) pts = 3;
                else if (elapsed <= 120) pts = 2;

                room.scores[data.user] += pts;
                
                io.to(data.roomId).emit('guess_correct', {
                    winner: data.user,
                    pts: pts,
                    word: room.currentWord,
                    scores: room.scores
                });

                // 準備下一輪
                room.currentTurnIdx = (room.currentTurnIdx + 1) % room.players.length;
                setTimeout(() => startNewDrawTurn(data.roomId), 3000);
                return;
            }
        }
        // 普通聊天發送
        io.to(data.roomId).emit('receive_chat', {
            user: data.user,
            text: data.text,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        });
    });

    // 畫布同步
    socket.on('drawing', (data) => {
        socket.to(data.roomId).emit('drawing', data);
    });

    // 賓果同步
    socket.on('bingo_click', (data) => {
        io.to(data.roomId).emit('bingo_sync', data.num);
    });

    // --- 斷線處理 ---
    socket.on('disconnect', () => {
        if (socket.roomId && rooms[socket.roomId]) {
            const room = rooms[socket.roomId];
            room.players = room.players.filter(p => p.id !== socket.id);
            
            console.log(`玩家 ${socket.username} 離開，房間剩餘: ${room.players.length}`);

            if (room.players.length === 0) {
                delete rooms[socket.roomId];
            } else {
                // 如果房主離開，移交房主權限
                if (room.host === socket.id) {
                    room.host = room.players[0].id;
                }
                io.to(socket.roomId).emit('room_update', {
                    roomId: socket.roomId,
                    players: room.players,
                    hostId: room.host,
                    gameStarted: room.gameStarted
                });
            }
        }
    });
});

// 管理員 API
app.get('/admin/data', (req, res) => {
    if (req.query.key !== ADMIN_KEY) return res.status(403).send("密鑰錯誤");
    res.json(rooms);
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`伺服器成功啟動：http://localhost:${PORT}`);
});
